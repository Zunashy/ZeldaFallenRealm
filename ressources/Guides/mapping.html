<!DOCTYPE html>
<html>
<head>
<title>mapping</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>Guide de création des maps</h1>
<p>Les maps sont les environements où Link évoluera dans le jeu. Elles sont donc fondamentales à son fonctionnement.</p>
<p>Les maps sont composées d'un décor &quot;inerte&quot; (donc à peu de chose près, une image de fond et des éléments de terrain), les tiles ; et d'entités dynamiques généralement contrôlées par un script (dont Link !).<br />
Dans ce guide je présenterai la méthodes à suivre pour créer et éditer des maps, placer les tiles, et les entités, etc.</p>
<p>Il n'est pas nécessaire d'utiliser un autre logiciel que l'éditeur solarus pour éditer les maps.</p>
<p>Avant de commencer, ouvrez donc l'éditeur solarus et ouvrez une map en double-cliquant dessus dans l'arborescence à gauche ; ou créez en une avec clic droit sur le dossier qui la contiendra (les maps sont toujours organisées en dossiers) -&gt; Nouvelle map.
<img src="img/mapeditor1.PNG" alt="Image indisponible" /></p>
<p>A droite, l'aperçu de la map ; dans la partie centale haute vous pouvez modifier certains propriétés de votre map, telles que sa taille ou la musique qui se jouera dessus.</p>
<p>Comme expliqué précédemment, la map est composée d'un décor et d'éléments dynamiques posés dessus.</p>
<h2>Les tiles</h2>
<p>Le décor d'une map est composé d'une multitude d'images carrées, de taille 8x8 ou parfois plus, souvent répétés.  </p>
<p><strong>Exemple</strong> : sur cette image, on peut voir deux tiles différentes, de 16x16 pixels<br />
<img src="img/tiles1.PNG" alt="Image indisponible" /><br />
Celle de droite n'est présente qu'une fois, mais celle de droite à été répétée pour créer le motif du sol.</p>
<h4>Tilesets</h4>
<p>Ces images sont regroupées sur des <strong>tilesets</strong>, de grandes images contenant toutes les tiles nécessaires à une map (on trouvera par exemple un tileset pour les maisons de base, un pour le donjon 1, etc). Avant de commencer à palcer des tiles sur une map et donc construire sond écor, il faut donc choisir le tileset, dans les propriétés de la map (au centre de l'écran).</p>
<p>(note : vous pouvez aussi aller voir le tileset directement, avec chaque tile et leurs propriétés dont on parlera plus tard, dans le dossier <code>data/tilesets/</code>, ou en cliquant sur l'icône crayon à côté du tileset sélectionné)</p>
<h4>Placer des tiles</h4>
<p>Une fois le tileset choisi, il apparaît en dessous de propriétés, juste à droite de l'aperçu de la map.<br />
A partir de là, c'est très simple : on clique sur une tile pour la sélectionner, pour on clique sur la map là où on veut la placer.<br />
Il existe quelques subtilités que j'ajouterait plus tard (mais n'hésitez pas à demander à Zuna en attendant), mais en voici quelques unes assez indispensables :</p>
<ul>
<li>Maintenir clic gauche appuyé quand on place une tile sur la map et déplacer la souris dans une direction répète la tile, utile pour les grandes surfaces constituées d'une seule tile répétée. Certaines tiles ne peuvent pas être répétées ; d'autres ne peuvent l'être que dans une seule direction (ex : les murs horizontaux ne peuvent être répétés qu'à l'horizontale, etc)</li>
<li>Double-clic sur une tile pour afficher ses propriétés : il y est par exemple possible de chanegr manuellement leur position et leur taille.</li>
</ul>
<p>Il est important de noter que certains tiles sont animées (toutes les frames de l'animation sont présentes côte à côte sur le tileset).</p>
<p>Note : certaines tiles doivent parfois se chevaucher : pour décider de laquelle s'affiche au dessus, clic-droit -&gt; mettre à l'arrière-plan / mettre au premier plan. (voir aussi le paragraphe &quot;couches&quot;)</p>
<h4>Type de terrain</h4>
<p>De plus, il s'avère qu'en réalité j'ai menti : les tiles ne sont pas uniquement un décor inerte ; certaines peuvent interagir avec les entités. En effet, les tiles possèdent un <em>type de terrain</em> (on ne peut d'ailleurs pas savoir le type de terrain d'une tile dans l'éditeur de map : pour savoir le type de terrain d'une tile, allez voir directement le tileset).<br />
Ces types sont :  </p>
<ul>
<li>Traversable : aucun effet.</li>
<li>Mur : Est considéré comme un obstacle pour les entités.</li>
<li>Muret : Par défaut, exactement pareil, cependant j'ai codé certaines entités de manière à passer au dessus, comme les flèches ou les entités volantes.  </li>
<li>Vide : comme traversable, avec une différence que l'on verra au prochain paragraphe.</li>
</ul>
<p>Les autres ont des effets plus particuliers, et sont assez explicites :</p>
<ul>
<li>Trous, piquants, eau profonde, lave : tiles qui auront chacune particulier sur les entités passant dessus, en particulier sur Link (tue les monstres directement, et inflige des dégâts à Link avant de le faire revenir en arrière).</li>
<li>Eau peu profonde, herbe : Modifie un peu l'animation de Link et joue un son lorsqu'il marche dessus. </li>
<li>Et qques autres un peu osef</li>
</ul>
<h4>Couches</h4>
<p>En effet, les maps se sont pas des environements <em>entièrement</em> 2D : les tiles peuvent être à différentes hauteurs, symbolisées par des couches/layers. Toutes les tiles sont par défaut à la couche 0, mais on peut changer ça avec un simple clic-droit.<br />
Le système est assez simple, les tiles de la couche 1 s'affiche toujours au dessus de la couche 0 (modifier l'ordre des tiles avec clic-droit -&gt; mettre à l'arrière-plan / mettre au premier plan n'a d'effet qu'au sein d'une même couche : mettre à l'arriere plan une tile de la couche 1 l'affichera sous les tiles de la couche 1 mais au dessus de toutes les tiles de la couche 0)<br />
Nous y reviendront dans la partie dédiée, mais les entités se trouvent toujours sur une couche : si Link de trouve sur une couche, il y restera tant qu'il y a une tile Traversable sous ses pieds à la même couche que lui ; s'il se retrouve sur un tile avec Vide comme type de terrain, ou juste un endroit sans tile, il &quot;tombera&quot; (descendra les couches jusqu'à retomber sur une tile non vide ou à la couche 0.  </p>
<p>(note: les entités sont toujours affichées au dessus des tiles de leur couche ; pour qu'une tile s'affiche par dessus Link, il faudra la placer sur une couche supérieure à celle où se trouvera Link)</p>
<h2>Entités</h2>
<p>Tandis que les tiles sont la partie inerte de la map, sa base, qui ne pourra pas changer pendant le jeu, les entités sont des objets capables de se déplacer, apparaître ou disparaître, effectuer diverses actions, pendant le jeu. Elles seront donc, contrairement aux tiles, contrôlables par les scripts du jeu. <br />
Certaines seront gérées par le jeu, mais la plupart devront être placées sur la map au même titre que les tiles.</p>
<p>Il existe de nombreux types d'entités, qui seront décrits plus tard.</p>
<p>Pour placer des entités, cliquez simplement sur les icones correspondantes au dessus de l'aerçu de la map, puis placez les comme des tiles.
<img src="img/entities_icons.png" alt="Image indisponible" /><br />
Lorsque vous placez une entité, une fenêtre s'affiche, vous permettant de modifier ses propriétés, notament son nom, sa taille (rarement utile) ou le sprite qui y est associé.</p>
<p>Les différents types d'entités sont : </p>
<h5>Hero</h5>
<p>Le personnage jouable, c'est à dire Link dans notre jeu. Cette entité existe toujours sur la map et est entièrement gérée par le jeu, vous n'avez donc pas beosin de la créer.</p>
<h5>Destination</h5>
<p>Entité n'ayant aucun effet. Elles sont cependant très utiles dans la mesure où elles permettent de &quot;marquer&quot; une position : lorsque Link doit être téléporté (ce qui inclut surtout le moment où il arrive sur la map) il est généralement envoyé vers une destination. Il est donc important de donner des noms explicites aux destinations.<br />
Note : il est possible d'indiquer qu'une destination est la detination par défaut de la map : elle sera utilisée si on téléporte Link vers cette map sans spécifier de destination.</p>
<p>(note : il est possible de donner un sprite à une destination mais ce n'est généralement pas nécessaire)</p>
<h5>Téléporteurs</h5>
<p>Si Link se trouve sur un téléporteur, il sera envoyé vers la map et à la destination spécifiées dans les propriétés. 
Il est également possible de spécifier dans les propriétés le type de transition (fondu, immédiat ou scrolling. Le type scrolling est complexe à utiliser et nécessitera des explications supplémentaires).
Ils seront généralement couplés avec une destination placée à peu près au même endroit. En effet, on les utilisera généralement pour une transition entre deux maps : par exemple, pour l'entrée d'une maison, à l'extérieur on mettra une destination nommée &quot;maison_to_outdoor&quot; et un téléporteur au niveau de la porte, une destination &quot;from_outdoor&quot; et un téléporteur à l'entrée de la maison ; le téléporteur de dehors envoyant donc vers la map de la maison à la destination &quot;from_outdoor&quot; et vice versa.</p>
<p>il est possible de donner un sprite à un téléporteur mais ce n'est généralement pas nécessaire)</p>
<h5>Trésor ramassable</h5>
<p>Un item que link obtiendra s'il le touche. Le concept d'item est très large dans Solarus, dépendant de la manière dont c'est codé ça peut désigner autant un objet de l'inventaire qu'un réceptacle de coeur ou un rubis.
Les trésors sont en réalité rarement placés directement sur la map (+ souvent drop par des enemis ou trouvés dans un coffre).<br />
Lorsque vous placez un trésor, vous devez choisir l'item dont il s'agit, mais également sa variante. La variante peut avoir de nombreuses significations (pour un rubis : sa couleur, pour l'épée, son niveau, etc). Des informations sur les différents items (dont la significations de leurs variantes) sont disponibles sur le google doc.</p>
<p>Les items que peuvent représenter les trésors ramassables regroupent :  </p>
<ul>
<li>Les items utilisables (dont l'épée)</li>
<li>Les rubis</li>
<li>Les coeurs</li>
<li>Les fragments/réceptacles de coeur</li>
<li>Les clés</li>
</ul>
<p>(note : on ne donne pas de sprite à un trésor, le sprite de cette entité correspondant toujours à celui associé à l'item en question)</p>
<h5>Destructible</h5>
<p>Objet pouvant être détruit par Link, comme un buisson coupable à l'épée par exemple.   <br />
En plus du sprite, il existe de nombreux paramètres pour les destructibles :</p>
<ul>
<li>La manière de le détruire (s'il est possible de le détruire avec une explosion, avec l'épée, etc)</li>
<li>S'il est possible de le soulever (Link peut en effet soulever et porter certains éléments du décor)</li>
<li>S'il doit possède un type de terrain : si le destructible doit se comporter comme un terrain particulier (Voir &quot;Tiles&gt;Terrain). Ainsi si cette propriété est &quot;mur&quot;, le destructible ne sera pas traversable.</li>
<li>Et évidemment, son sprite.</li>
</ul>
<h5>Coffre</h5>
<p>Objet contenant un trésor, spécifié dans les propriétés (avec sa variante), que Link obtiendra en l'ouvrant.<br />
Il existe plusieurs modes d'ouverture : </p>
<ul>
<li>&quot;Par le héros&quot; : Link peut l'ouvrir à tout moment</li>
<li>&quot;Par le héro, item nécessaire&quot; : Link peut l'ouvrir s'il possède un certain item (si l'item en question gère la possession, ce qui inclut les petites clés ou les items d'inventaire mais pas les rubis ou les fragments de coeurs, qui ne sont pas réellement possédés par Link). Cocher &quot;retirer/décrémenter l'item&quot; enlèvera cet item à Link (pour les objets uniques comme les objets d'inventaire) ou lui en retirera un (pour les items dont Link possède une certaine quantité, comme les clés).</li>
<li>&quot;Par le héros, variable sauvegardée nécessaire&quot; : ouvrable seulement si une certaine &quot;variable sauvegardée&quot; est présente dans la sauvegarde. Les variables sauvegardées sont gérées de différents manières par le code, et peuvent représenter n'importe quel élément qui doit être sauvegardé (et qui n'est pas un item). Cette option doit donc être utilisée si Link ne peut ouvrir le coffre qu'à une condition qui n'est pas liée à un item : généralement, à voir avec les codeurs. </li>
</ul>
<h5>Enemi</h5>
<p>Un enemi (no shit sherlock). Il faudra spécifier le &quot;modèle d'enemi&quot; (quel enemi c'est, en gros), et éventuellement la direction vers laquelle il regarde au lancement de la map.
Les enemis sont généralement réinitialiés (et donc réapparaissent s'ils ont été tués) quand on change de map ou qu'on ferme le jeu : l'option &quot;sauvegarder l'état&quot; permet de ne pas les faire réapparaître, utile pour les boss surtout.</p>
<p>(note : on ne donne pas de sprite à un enemi, son script s'occupera de créer un sprite)</p>
<h5>PNJ</h5>
<p>Un personnage avec qui Link pourra généralement interagir. Outre le sprite et la direction, il faudra spécifier l'effet de l'interaction :</p>
<ul>
<li>Le souvent, &quot;afficher un dialogue&quot; en indiquand le nom du dialogue (les dialogues sont indiqués dans le fichier <code>languages/&lt;langue&gt;/dialogs</code> dans l'arborescence à gauche de l'éditeur), pour les PNJ qui n'ont qu'un simple dialogue.</li>
<li>Appeler le script de la map lancera une fonction définie dans le script de la map. Utile pour des PNJ plus complexe ou dont le dialogue évolue souvent (il faudra évidemment voir avec les codeurs pour implémenter ce PNJ dans le script de la map)</li>
<li>Appeler le script d'un item : pas compris l'utilité, n'utilisez jamais ça</li>
</ul>
<h5>Séparateurs</h5>
<p>Tehniquement, les séparateurs agissent comme &quot;un obstacle pour la caméra&quot; (c'est à dire la zone affichée à l'écran, qui doit suivre Link=. D'un point de vue plus pratique, un séparateur est une ligne que la caméra ne peut pas traverser, sauf si Link la traverse, auquel cas la caméra passera de l'autre côté avec une petite animation de scrolling.  </p>
<p>(Lorsque Link vient de traverser un séparateur, sa position est sauvegardée en tant que &quot;safe position&quot; : c'est ici qu'il sera ramené s'il tombe dans un trou/lave/etc. Pour que le jeu ne change pas la &quot;safe position&quot; quand Link traverse un séparateur, il faut appliquer la propriété <code>no_save</code> au séparateur ; voir partie Map Features)</p>
<h5>Capteurs</h5>
<p>Un capteur est une entité qui s'activera quand link passera dessus. L'activation n'a pas d'effet direct par défaut, mais est utilisable par le script de la map, ou par les <em>map features</em> (voir partie dédiée).<br />
Lorsque Link quitte le capteur, il n'est plus considéré comme activé : pour qu'un capteur reste activé après le départ de Link, lui appliquer la propriété &quot;persistent&quot; (voir partie Map Features)</p>
<h5>Blocs</h5>
<p>Les blocs sont des entités immobiles, considérés comme des murs, et que Link peut pousser ou tirer (il est possible de spécifier si Link peut tirer ou pousser dans les propriétés de l'entité). Les blocs poussables présents dans tous les Zelda 2D, en gros.</p>
<h5>Interrupteurs</h5>
<p>Entité qu'il est possible d'activer. Par défaut elle s'active si Link marche dessus, mais il est possible d'indiquer dans les propriétés que l'interrupteur ne s'active que si un bloc est posé dessus).<br />
De même que pour les capteurs, l'activation n'a pas d'effet direct par défaut, mais est utilisable par le script de la map, ou par les <em>map features</em> (voir partie dédiée).  </p>
<h5>Entités custom</h5>
<p>Une entité programmable : plus précisément, elle n'a aucun effet mais peut avoir son propre script ou juste être utilisée par celui de la map. Il est possible (mais pas obligatoire) d'indiquer un sprite et surtout un script.</p>
<p>Les scripts disponibles (et utiles pour le mapping) sont : </p>
<ul>
<li>interaction_box : Doit être liée à une autre entité &quot;cible&quot; avec laquelle il est possible d'interagir, comme un PNJ, en lui donnant la propriété <code>target : &lt;nom de l'entité cible&gt;</code> (voir partie Propriétés Custom plus bas). Lorsque Link interagira avec cette entité, ce sera comme si il avait interagi avec l'entité cible.<br />
Utilisation typique : en placer une sur un objet du décor et la lier à un PNJ pour déclencher le dialogue de ce PNJ lorque Link interagit avec l'objet.</li>
<li>platform : Une plateforme mouvante. Une plateforme (donc une zone solide sur laquelle Link peut marcher) en mouvement. Sa direction de déplacement doit être indiquée en lui donnant la propriété <code>direction : &lt;ID de la direction&gt;</code> (les ID de directions vont de 0 pour la droite à 3 pour le bas). Elle s'arrête en touchant un mur.
(il est important de spécifier un sprite, sinon il s'agira simplement d'une plateforme invisible. Elle prendra la taille du sprite)</li>
<li>dungeon_statue_eye : A placer sur les statues à l'entrée du donjon. Affiche simplement un oeil regardant vers Link.</li>
</ul>
<h3>Propriétés Custom</h3>
<p>Il est possible d'affecter des propriétés particulières aux entités, avec le nom qu'on veut. C'est d'ailleurs nécessaire pour contrôler les fonctionnement de la plupart des entités custom.
Pour cela, il faut regarder la partie &quot;propriétés utilisateurs&quot;, en bas de la fenêtre de configuration des entités, cliquer sur le &quot;+&quot; vert, et spécifier le nom de la propriété et sa valeur.<br />
Dans ce guide, je présenterai généralement les propriété avec le format <code>nom : valeur</code>.</p>
<p>Outre les entités custom, il peut être utile d'affecter des propriétés custom à d'autres types d'entité pour activer certaines fonctionnalités que j'ai créés pour le jeu, les <em>map features</em>.</p>
<h3>Map features</h3>
<p>La plupart du temps, il s'agit d'affecter une propriété à une entité afin de modifier son comportement. Elles sont surtout utile pour &quot;programmer&quot; le fonctionnement des donjons, mais sont utiles dans beaucoup d'autres situation. 
A noter que les map features ne sont pas activées par défaut, pour pouvoir utiliser une map feature sur une map il faudra généralement <code>on_started_</code> de son code. 
(on accède au code d'une map en cliquant sur l'icone en haud à droite des propriétés de la map. Il suffit alors d'ajouter la ligne entre <code>function on_started_()</code> et <code>end</code>)</p>
<p>Les maps features disponibles actuellement sont les suivantes : </p>
<ul>
<li>
<p>Group Loot : il est possible de faire en sorte que Link doive tuer tout un groupe d'enemi pour loot un item (le dernier enemi à mourir droppera l'item). Pour cela, ajouter la propriété <code>group_loot : nom_de_l'item#variante</code> à tous les enemis du groupe. (le <code>#variante</code> est inutile si l'item n'a pas plusieurs variantes).
L'item spécifié ne sera drop que lorsque tous les enemis avec la propriété <code>group_loot</code> avec la même valeur auront été tués. 
Exemple : Les 3 moblins devant le donjon 1 (sur la plage) possèdent la propriété <code>groop_loot : great_key</code>, ce qui signifie que quand le dernier est tué, il drop la grande clé.</p>
</li>
<li>
<p><strong>Triggers</strong> : le coeur de la gestion du fonctionnement des donjons.<br />
Un trigger est un couple <code>propriété : valeur</code> qui va permettre de déclencher une action particulière quand l'entité respecte certaines conditions (généralement, quand un certain évènement concernant l'entité sera survenu). Le nom de la propriété doit être le type de conditions, la valeur l'action à réaliser.<br />
Les conditions supportés pour l'instant sont : </p>
<ul>
<li><code>death_trigger</code> : est activé quand l'entité meurt (pour un enemi). S'active en ajoutant <code>self:init_enemies_event_triggers()</code> .</li>
<li><code>activate_trigger</code> : a placer sur un capteur ou un bouton (ou un bloc, voir plus bas), s'activera quand l'entité sera activée (quand link passe sur le capteur, active le bouton, ou déplace le bloc (voir plus bas pour les blocs). S'active en ajoutant <code>self:init_activate_triggers()</code>.  
</li>
</ul>
<p>A noter que si plusieurs entités possèdent le même trigger (c'est à dire un même type de conditions <em>avec la même action</em>), l'action ne sera déclenchée que quand les conditions seront vérifiées pour toutes les entités : si plusieurs enemis possèdent une propriété <code>death_trigger</code> avec la même valeur (donc la même action), cette action ne sera réalisée que quand tous les enemis en question auront été tués.<br />
De même, si plusieurs boutons possèdent le même <code>activate_trigger</code>, l'action ne sera réalisée que si tous les boutons sont activés (donc si l'un d'entre eux n'est plus activé, ça ne fonctionnera pas).</p>
<p>Les actions (qui doivent donc être la valeur de la propriété) possibles sont : </p>
<ul>
<li><code>open_door_nom</code> : ouvre toute porte donc le nom commence par &quot;nom&quot; ou &quot;door_nom&quot; (remplacer nom par le nom de la porte (sans blague) mais pas le door)</li>
<li><code>spawn_nom</code> : fait apparaître l'entité nommée &quot;nom&quot;. L'entité doit être déjà présente sur la map mais désactivée (pour cela, quand vous la placez sur la map, décochez la case &quot;actif au démarrage&quot; : quand une entité est désactivée c'est comme si elle n'existait pas).</li>
<li><code>treasure_nom</code> : comme pour <code>spawn_</code>, fait apparaître le trésor ramassable nommé &quot;nom&quot; ou &quot;treasure_nom&quot;. (cela dit vous pouvez toujours utiliser <code>spawn_</code> pour les trésors, comme vous voulez)</li>
</ul>
<p>Quelques exemples : </p>
<ul>
<li>si 3 enemis possèdent la propriété <code>death_trigger : treasure_key_1</code>, et qu'il existe sur la map une clé (c'est à dire un trésor ramassable de l'item clé, désactivé) nommée &quot;key_1&quot;, elle apparaîtra quand les 3 enemis auront été tués.</li>
<li>si un interrupteur s'activant avec un bloc et 3 capteurs persistants (voir map features liées aux capteurs) possèdent la propriété <code>activate_trigger : door_1</code>, et qu'il existe deux portes nommés &quot;door_1-1&quot; et &quot;door_1-2&quot;,  si Link passe sur les 3 capteurs et qu'un bloc se trouve actuellement sur l'interrupteur, les portes s'ouvriront.</li>
</ul>
</li>
<li>
<p>Séparateurs : il existe deux map features concernant les Séparateurs : </p>
<ul>
<li><code>no_save</code> : si un séparateur possède la propriété <code>no_save : 1</code> il ne sauvegardera pas la position de Link quand celui-ci le traversera (voir partie Séparateurs).</li>
<li>dungeon style scrollings :  cette Map feature ne nécessite pas de propriété, juste d'ajouter <code>self:init_reset_separators(true)</code> au script. Si cette ligne est présente dans la fonction <code>on_started_</code>, passer un séparateur réinitialisera complètement les enemis et blocs présents sur la map.<br />
Par exemple, dans la plupart des Zelda 2D, quand Link sort d'une salle et y retourne, les enemis sont de nouveau là (sauf les boss). Ici c'est la même idée, si dans un donjon on met des séparateurs entre chaque salle, le donjon ne comportera comme un donjon de Zelda 1.<br />
Il existe deux propriété permettant de modifier ce fonctionnement : </li>
<li>donner la propriété <code>auto_separator : 1</code> à un séparateur désactivera ce fonctionnement pour ce séparateur. Si dans la ligne d'activation on ne met pas <code>true</code> entre parenthèses, ce sera la contraire : seuls les séparateurs avec cette propriété auront ce fonctionnement.</li>
<li>donner la propriété <code>no_reset : 1</code> à un ennemi/bloc l'excluera de la réinitalisation, il ne sera jamais réinitialisé.</li>
</ul>
</li>
<li>
<p>Capteurs persistents : donner la propriété <code>persistent : 1</code> à un capteur fera qu'il sera toujours considéré comme activé même si Link n'est plus dessus.</p>
</li>
<li>
<p>Blocs activables : donner la propriété <code>activate_when_moved : 1</code> à un bloc fera qu'il sera considéré comme activé quand Link le déplacera. Il restera alors toujours activé, sauf s'il est réinitialisé (par un séparateur par exemple, voir plus haut)</p>
</li>
<li>
<p>Entités liées au scénario : dans Fallen Realm, l'avancement de la quête est représenté par une valeur numérique appelée story state (je ferai un document qui explique en détail le déroulement de la quête prochainement, la valeur correspondant à chaque étape sera expliqué).<br />
La propriété <code>min_story_state : n</code> fera qu'une entité n'apparaît que si le story state est de n au moins.<br />
La propriété <code>max_story_state : n</code> fera qu'une entité n'apparaît que si le story state est de n au plus.  
</p>
</li>
</ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
